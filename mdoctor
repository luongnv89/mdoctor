#!/usr/bin/env bash
#
# mdoctor - Unified System Doctor CLI
#
# A single entry-point for checking, cleaning, fixing, and diagnosing macOS / Linux (Debian).
#
# Usage:
#   mdoctor <command> [options]
#
# Commands:
#   check      Run system health audit (read-only)
#   clean      Run system cleanup (dry-run by default)
#   fix        Apply common fixes
#   info       Show system information summary
#   list       List all modules with category & risk
#   history    View health score trends over time
#   benchmark  Run disk, network, CPU benchmarks
#   update     Update mdoctor to latest stable release
#   version    Show mdoctor version
#   help       Show this help message
#

set -uo pipefail

########################################
# VERSION
########################################

MDOCTOR_VERSION="2.1.0"

# Append short git commit hash if inside a git repo
_mdoctor_commit=""
if command -v git >/dev/null 2>&1; then
  _mdoctor_commit="$(git -C "$(dirname "$0")" rev-parse --short HEAD 2>/dev/null || true)"
fi
if [ -n "$_mdoctor_commit" ]; then
  MDOCTOR_VERSION_FULL="${MDOCTOR_VERSION}+${_mdoctor_commit}"
else
  MDOCTOR_VERSION_FULL="${MDOCTOR_VERSION}"
fi

########################################
# RESOLVE INSTALL DIRECTORY
########################################

# Find the real script directory (handles symlinks)
resolve_script_dir() {
  local resolved
  # Try realpath first (available on modern macOS)
  if resolved="$(realpath "$0" 2>/dev/null)"; then
    dirname "$resolved"
    return
  fi
  # Try perl as fallback (always available on macOS)
  if resolved="$(perl -e 'use Cwd "abs_path"; use File::Basename; print dirname(abs_path($ARGV[0])) . "\n"' "$0" 2>/dev/null)"; then
    echo "$resolved"
    return
  fi
  # Last resort: use known install location or script dir
  if [ -d "${HOME}/.mdoctor/lib" ]; then
    echo "${HOME}/.mdoctor"
  else
    cd -P "$(dirname "$0")" && pwd
  fi
}

MDOCTOR_DIR="$(resolve_script_dir)"

# Source platform detection early (before any platform-conditional logic)
source "${MDOCTOR_DIR}/lib/platform.sh"

# Runtime diagnostics flag (can be enabled per-command via --debug)
MDOCTOR_DEBUG="${MDOCTOR_DEBUG:-false}"

########################################
# COLORS
########################################

if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
  RED="$(tput setaf 1)"
  GREEN="$(tput setaf 2)"
  YELLOW="$(tput setaf 3)"
  BLUE="$(tput setaf 4)"
  CYAN="$(tput setaf 6)"
  BOLD="$(tput bold)"
  DIM="$(tput dim)"
  RESET="$(tput sgr0)"
else
  # shellcheck disable=SC2034
  RED="" GREEN="" YELLOW="" BLUE="" CYAN="" BOLD="" DIM="" RESET=""
fi

########################################
# HELPERS
########################################

banner() {
  echo "${BOLD}${CYAN}"
  echo '  __  __ ____             _             '
  echo ' |  \/  |  _ \  ___   ___| |_ ___  _ __ '
  echo ' | |\/| | | | |/ _ \ / __| __/ _ \| '\''__|'
  echo ' | |  | | |_| | (_) | (__| || (_) | |   '
  echo ' |_|  |_|____/ \___/ \___|\__\___/|_|   '
  echo "${RESET}"
  echo "${DIM}  Machine Doctor v${MDOCTOR_VERSION_FULL} - Keep your system healthy${RESET}"
  echo
}

error() {
  echo "${RED}Error:${RESET} $*" >&2
}

md_path_size_kb() {
  local path="${1-}"
  if [ -z "$path" ] || [ ! -e "$path" ]; then
    echo 0
    return 0
  fi
  du -sk "$path" 2>/dev/null | awk '{print $1+0}'
}

md_find_size_kb() {
  local base="${1-}"
  shift || true

  if [ -z "$base" ] || [ ! -d "$base" ]; then
    echo 0
    return 0
  fi

  local total=0
  local p=""
  while IFS= read -r -d '' p; do
    local sz=0
    sz=$(du -sk "$p" 2>/dev/null | awk '{print $1+0}')
    total=$((total + sz))
  done < <(find "$base" "$@" -print0 2>/dev/null)

  echo "$total"
}

md_human_kb() {
  local kb="${1:-0}"
  if declare -f human_readable_kb >/dev/null 2>&1; then
    human_readable_kb "$kb"
    return 0
  fi
  if (( kb >= 1048576 )); then
    awk -v v="$kb" 'BEGIN {printf "%.2f GB", v/1048576}'
  elif (( kb >= 1024 )); then
    awk -v v="$kb" 'BEGIN {printf "%.2f MB", v/1024}'
  else
    printf "%d KB" "$kb"
  fi
}

cmd_clean_preflight_summary_module() {
  local module="${1-}"
  local days="${2:-7}"
  local total_kb=0

  echo
  echo "${BOLD}${YELLOW}== Pre-flight Safety Summary (force mode) ==${RESET}"
  echo "Module: ${module}"
  echo "This run will perform destructive cleanup operations."
  echo "Touched targets:"

  local add_path
  add_path() {
    local label="$1"
    local path="$2"
    local sz=0
    sz=$(md_path_size_kb "$path")
    total_kb=$((total_kb + sz))
    printf "  - %-30s %s (~%s)\n" "$label" "$path" "$(md_human_kb "$sz")"
  }

  case "$module" in
    trash)
      add_path "Trash" "$(platform_trash_dir)"
      ;;
    caches)
      add_path "User caches" "$(platform_cache_dir)"
      ;;
    logs)
      local log_dir
      log_dir="$(platform_user_log_dir)"
      local logs_kb=0
      logs_kb=$(md_find_size_kb "$log_dir" -type f -mtime "+${days}")
      total_kb=$((total_kb + logs_kb))
      printf "  - %-30s %s (~%s)\n" "Old logs (>${days}d)" "$log_dir" "$(md_human_kb "$logs_kb")"
      ;;
    downloads)
      local dl_kb=0
      dl_kb=$(md_find_size_kb "${HOME}/Downloads" -type f -size +500M -mtime "+${days}")
      total_kb=$((total_kb + dl_kb))
      printf "  - %-30s %s (~%s)\n" "Large downloads (>${days}d)" "${HOME}/Downloads" "$(md_human_kb "$dl_kb")"
      ;;
    browser)
      if is_macos; then
        add_path "Chrome cache" "${HOME}/Library/Caches/Google/Chrome"
        add_path "Safari cache" "${HOME}/Library/Caches/com.apple.Safari"
        add_path "Firefox cache" "${HOME}/Library/Caches/Firefox"
      else
        add_path "Chrome cache" "${HOME}/.cache/google-chrome"
        add_path "Firefox cache" "${HOME}/.cache/mozilla/firefox"
        add_path "Chromium cache" "${HOME}/.cache/chromium"
      fi
      ;;
    dev)
      add_path "pip cache" "${HOME}/.cache/pip"
      add_path "npm cache" "${HOME}/.npm"
      if is_macos; then
        add_path "pip cache (Library)" "${HOME}/Library/Caches/pip"
        add_path "npm cache (Library)" "${HOME}/Library/Caches/npm"
        add_path "Yarn cache" "${HOME}/Library/Caches/Yarn"
        add_path "pnpm store" "${HOME}/Library/pnpm/store"
        echo "  - Homebrew cleanup/autoremove (size estimate: n/a)"
      fi
      echo "  - Docker prune (size estimate: n/a)"
      ;;
    crash_reports)
      local crash_dir crash_kb
      while IFS= read -r crash_dir; do
        crash_kb=$(md_find_size_kb "$crash_dir" -type f -mtime "+${days}")
        total_kb=$((total_kb + crash_kb))
        printf "  - %-30s %s (~%s)\n" "Crash reports" "$crash_dir" "$(md_human_kb "$crash_kb")"
      done < <(platform_crash_dirs)
      ;;
    ios_backups)
      local ios_kb=0
      ios_kb=$(md_find_size_kb "${HOME}/Library/Application Support/MobileSync/Backup" -mindepth 1 -maxdepth 1 -type d -mtime "+${days}")
      total_kb=$((total_kb + ios_kb))
      printf "  - %-30s %s (~%s)\n" "iOS backups (>${days}d)" "${HOME}/Library/Application Support/MobileSync/Backup" "$(md_human_kb "$ios_kb")"
      ;;
    xcode)
      add_path "Xcode DerivedData" "${HOME}/Library/Developer/Xcode/DerivedData"
      local arc_kb=0
      arc_kb=$(md_find_size_kb "${HOME}/Library/Developer/Xcode/Archives" -mindepth 1 -maxdepth 1 -type d -mtime "+${days}")
      total_kb=$((total_kb + arc_kb))
      printf "  - %-30s %s (~%s)\n" "Xcode Archives (>${days}d)" "${HOME}/Library/Developer/Xcode/Archives" "$(md_human_kb "$arc_kb")"
      add_path "CoreSimulator caches" "${HOME}/Library/Developer/CoreSimulator/Caches"
      echo "  - xcrun simctl delete unavailable (size estimate: n/a)"
      ;;
    apt)
      add_path "APT cache" "/var/cache/apt/archives"
      echo "  - apt autoremove (size estimate: n/a)"
      ;;
    dev_caches)
      add_path "npm cache" "${HOME}/.npm"
      add_path "pip cache" "${HOME}/.cache/pip"
      add_path "Maven repo" "${HOME}/.m2/repository"
      add_path "Gradle caches" "${HOME}/.gradle/caches"
      add_path "Go module cache" "${HOME}/go/pkg/mod/cache"
      add_path "Cargo cache" "${HOME}/.cargo/registry/cache"
      if is_macos; then
        add_path "Xcode DerivedData" "${HOME}/Library/Developer/Xcode/DerivedData"
      fi
      echo "  - Docker prune (size estimate: n/a)"
      ;;
  esac

  echo
  echo "Estimated reclaim size: ~$(md_human_kb "$total_kb")"
  echo "${YELLOW}Note:${RESET} estimate is approximate and excludes some command-based cleanup results."
  echo
}

########################################
# COMMAND: check
########################################

cmd_check() {
  local module=""
  local json_flag=false
  local debug_flag=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --module|-m)
        module="$2"
        shift 2
        ;;
      --json)
        json_flag=true
        shift
        ;;
      --debug)
        debug_flag=true
        shift
        ;;
      --help|-h)
        echo "Usage: mdoctor check [options]"
        echo
        echo "Run system health audit (read-only, changes nothing)."
        echo
        echo "Options:"
        echo "  -m, --module <name>   Run only a specific check module"
        echo "  --json                Output results as JSON"
        echo "  --debug               Enable structured debug diagnostics"
        echo "  -h, --help            Show this help"
        echo
        echo "Check modules (all [SAFE] read-only):"
        echo "  Hardware:  battery, hardware, bluetooth, usb"
        echo "  System:    system, disk, updates, security, startup, network, performance, storage"
        echo "  Software:  homebrew, node, python, devtools, shell, apps, git_config, containers"
        return 0
        ;;
      *)
        error "Unknown option: $1"
        echo "Run 'mdoctor check --help' for usage."
        return 1
        ;;
    esac
  done

  if [ "$json_flag" = true ]; then
    export JSON_ENABLED=true
  fi

  if [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG=true
    export MDOCTOR_DEBUG
  fi

  if [ "$json_flag" = false ]; then
    echo "${DIM}mdoctor v${MDOCTOR_VERSION_FULL}${RESET}"
  fi

  if [ -n "$module" ]; then
    # Run a single check module
    local check_file="${MDOCTOR_DIR}/checks/${module}.sh"
    if [ ! -f "$check_file" ]; then
      error "Unknown check module: ${module}"
      echo "Available modules: battery, hardware, bluetooth, usb,"
      echo "  system, disk, updates, security, startup, network, performance, storage,"
      echo "  homebrew, node, python, devtools, shell, apps, git_config, containers"
      return 1
    fi

    # Source libraries (platform.sh already loaded at top level)
    source "${MDOCTOR_DIR}/lib/common.sh"
    source "${MDOCTOR_DIR}/lib/logging.sh"
    source "${MDOCTOR_DIR}/lib/disk.sh"
    source "${MDOCTOR_DIR}/lib/json.sh"
    source "${MDOCTOR_DIR}/lib/metadata.sh"

    # Initialize globals (used by sourced check modules)
    # shellcheck disable=SC2034
    STEP_CURRENT=0
    # shellcheck disable=SC2034
    STEP_TOTAL=1
    ACTIONS=()
    # shellcheck disable=SC2034
    WARN_COUNT=0
    # shellcheck disable=SC2034
    FAIL_COUNT=0
    # shellcheck disable=SC2034
    LOG_PATHS=()
    # shellcheck disable=SC2034
    LOG_DESCS=()
    # shellcheck disable=SC2034
    REPORT_MD=""

    init_colors
    debug_log "cmd_check module=${module} json=${json_flag} debug=${MDOCTOR_DEBUG}"

    # shellcheck source=/dev/null
    source "$check_file"

    # In JSON mode, silence human-readable stdout while running checks.
    if [ "$json_flag" = true ]; then
      exec 3>&1
      exec >/dev/null
    fi

    # Map module name to function
    case "$module" in
      system)      check_system ;;
      disk)        check_disk ;;
      updates)     check_updates_basic ;;
      homebrew)    check_homebrew ;;
      node)        check_node_npm ;;
      python)      check_python ;;
      devtools)    check_dev_tools ;;
      shell)       check_shell_configs ;;
      network)     check_network ;;
      battery)     check_battery ;;
      hardware)    check_hardware ;;
      bluetooth)   check_bluetooth ;;
      usb)         check_usb ;;
      security)    check_security ;;
      startup)     check_startup ;;
      performance) check_performance ;;
      apps)        check_apps ;;
      git_config)  check_git_config ;;
      containers)  check_containers ;;
      storage)     check_storage ;;
      apt)         check_apt ;;
    esac

    # Stop spinner after single-module check
    progress_stop

    if [ "$json_flag" = true ]; then
      # Restore stdout and emit machine-readable JSON only.
      exec >&3
      exec 3>&-

      local score penalty rating module_status
      penalty=$(( WARN_COUNT * 4 + FAIL_COUNT * 8 ))
      score=$(( 100 - penalty ))
      if (( score < 0 )); then
        score=0
      fi

      if (( score >= 90 )); then
        rating="Excellent"
      elif (( score >= 75 )); then
        rating="Good"
      elif (( score >= 50 )); then
        rating="Needs attention"
      else
        rating="Critical – fix issues ASAP"
      fi

      if (( FAIL_COUNT > 0 )); then
        module_status="fail"
      elif (( WARN_COUNT > 0 )); then
        module_status="warn"
      else
        module_status="ok"
      fi

      json_add_check "$module" "module" "SAFE" "$module_status" "Module check completed"

      local action
      for action in "${ACTIONS[@]}"; do
        json_add_action "$action"
      done

      json_build_output "$score" "$rating" "$WARN_COUNT" "$FAIL_COUNT"
      return 0
    fi

    # Show summary for single module
    if ((${#ACTIONS[@]} > 0)); then
      echo
      echo "${BOLD}Actions:${RESET}"
      local i=1
      for action in "${ACTIONS[@]}"; do
        echo "  ${i}. ${action}"
        i=$((i + 1))
      done
    fi
  else
    # Run full doctor
    if [ "$json_flag" = true ]; then
      JSON_ENABLED=true MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" MDOCTOR_VERSION="${MDOCTOR_VERSION}" bash "${MDOCTOR_DIR}/doctor.sh"
    else
      MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" bash "${MDOCTOR_DIR}/doctor.sh"
    fi
  fi
}

########################################
# COMMAND: clean
########################################

cmd_clean() {
  local force=false
  local module=""
  local debug_flag=false
  local interactive=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f)
        force=true
        shift
        ;;
      --module|-m)
        module="$2"
        shift 2
        ;;
      --interactive|-i)
        interactive=true
        shift
        ;;
      --debug)
        debug_flag=true
        shift
        ;;
      --help|-h)
        echo "Usage: mdoctor clean [options]"
        echo
        echo "Run system cleanup. Default is dry-run mode (shows what would"
        echo "be deleted without actually removing anything)."
        echo
        echo "Options:"
        echo "  -f, --force           Actually delete files (no dry-run)"
        echo "  -m, --module <name>   Run only a specific cleanup module"
        echo "  -i, --interactive     Interactively choose cleanup modules"
        echo "  --debug               Enable structured debug diagnostics"
        echo "  -h, --help            Show this help"
        echo
        echo "Cleanup modules:"
        echo "  System:    trash [LOW], caches [LOW], logs [LOW], downloads [LOW],"
        echo "             crash_reports [LOW], ios_backups [LOW]"
        echo "  Software:  browser [LOW], dev [LOW], xcode [LOW], dev_caches [LOW]"
        echo
        echo "Whitelist file: ~/.config/mdoctor/cleanup_whitelist"
        echo "Scope file: ~/.config/mdoctor/cleanup_scope.conf (dev_caches node_modules scan)"
        return 0
        ;;
      *)
        error "Unknown option: $1"
        echo "Run 'mdoctor clean --help' for usage."
        return 1
        ;;
    esac
  done

  if [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG=true
    export MDOCTOR_DEBUG
  fi

  echo "${DIM}mdoctor v${MDOCTOR_VERSION_FULL}${RESET}"

  local -a cleanup_modules=(trash caches logs downloads browser dev crash_reports dev_caches)
  if is_macos; then
    cleanup_modules+=(ios_backups xcode)
  fi
  if is_linux; then
    cleanup_modules+=(apt)
  fi

  is_valid_cleanup_module() {
    local needle="$1"
    local item
    for item in "${cleanup_modules[@]}"; do
      [ "$item" = "$needle" ] && return 0
    done
    return 1
  }

  cleanup_module_description() {
    case "$1" in
      trash)         echo "Empty Trash" ;;
      caches)        echo "User cache directories" ;;
      logs)          echo "Old log files" ;;
      downloads)     echo "Large files in Downloads" ;;
      browser)       echo "Browser cache cleanup" ;;
      dev)           echo "Developer tool caches" ;;
      crash_reports) echo "Old crash/diagnostic reports" ;;
      ios_backups)   echo "Old iOS backups" ;;
      xcode)         echo "Xcode DerivedData, archives, simulators" ;;
      dev_caches)    echo "Dependency/package manager caches" ;;
      apt)           echo "APT package cache cleanup" ;;
      *)             echo "" ;;
    esac
  }

  run_single_cleanup_module() {
    local selected_module="$1"
    local selected_force="$2"

    local clean_file="${MDOCTOR_DIR}/cleanups/${selected_module}.sh"
    if [ ! -f "$clean_file" ]; then
      error "Unknown cleanup module: ${selected_module}"
      echo "Available modules: trash, caches, logs, downloads, browser, dev,"
      echo "  crash_reports, ios_backups, xcode, dev_caches"
      return 1
    fi

    # Source libraries (platform.sh already loaded at top level)
    source "${MDOCTOR_DIR}/lib/common.sh"
    source "${MDOCTOR_DIR}/lib/logging.sh"
    source "${MDOCTOR_DIR}/lib/disk.sh"
    source "${MDOCTOR_DIR}/lib/safety.sh"
    source "${MDOCTOR_DIR}/lib/cleanup_scope.sh"

    # Initialize progress globals for spinner
    # shellcheck disable=SC2034
    STEP_CURRENT=0
    # shellcheck disable=SC2034
    STEP_TOTAL=1
    init_colors
    debug_log "cmd_clean module=${selected_module} force=${selected_force} debug=${MDOCTOR_DEBUG}"

    # Set globals (used by sourced cleanup modules via run_cmd)
    # shellcheck disable=SC2034
    DRY_RUN=true
    LOGFILE="$(platform_log_dir)/mdoctor_cleanup.log"
    # shellcheck disable=SC2034
    DAYS_OLD="${DAYS_OLD_OVERRIDE:-7}"

    if [ "$selected_force" = true ]; then
      # shellcheck disable=SC2034
      DRY_RUN=false
      cmd_clean_preflight_summary_module "$selected_module" "${DAYS_OLD}"
    fi

    mkdir -p "$(dirname "$LOGFILE")"
    if declare -f ensure_cleanup_whitelist_file >/dev/null 2>&1; then
      ensure_cleanup_whitelist_file
    fi
    if declare -f ensure_cleanup_scope_file >/dev/null 2>&1; then
      ensure_cleanup_scope_file
    fi

    # shellcheck source=/dev/null
    source "$clean_file"

    op_session_start "clean:module:${selected_module}"

    # Start spinner for single cleanup module
    # shellcheck disable=SC2034
    STEP_CURRENT=1
    progress_start "Cleaning ${selected_module}..."

    local module_rc=0

    case "$selected_module" in
      trash)          clean_trash || module_rc=$? ;;
      caches)         clean_user_caches || module_rc=$? ;;
      logs)           clean_logs || module_rc=$? ;;
      downloads)      clean_downloads_large_files || module_rc=$? ;;
      browser)        clean_browser_caches || module_rc=$? ;;
      dev)            clean_dev_stuff || module_rc=$? ;;
      crash_reports)  clean_crash_reports || module_rc=$? ;;
      ios_backups)    clean_ios_backups || module_rc=$? ;;
      xcode)          clean_xcode || module_rc=$? ;;
      dev_caches)     clean_dev_caches || module_rc=$? ;;
      apt)            clean_apt_cache || module_rc=$? ;;
    esac

    progress_stop

    if [ "$module_rc" -eq 0 ]; then
      op_session_end "ok"
    else
      op_session_end "error:${module_rc}"
      return "$module_rc"
    fi
  }

  select_interactive_modules() {
    local i=1
    local selected=""
    local input token idx selected_module
    local -a picks=()

    echo >&2
    echo "${BOLD}Interactive cleanup mode${RESET}" >&2
    echo "Select modules to run:" >&2

    for selected_module in "${cleanup_modules[@]}"; do
      printf "  [%d] %-14s %s\n" "$i" "$selected_module" "$(cleanup_module_description "$selected_module")" >&2
      i=$((i + 1))
    done

    echo >&2
    echo "Enter numbers (comma-separated), 'all', or press Enter to cancel:" >&2
    printf "> " >&2
    IFS= read -r input || true

    input="${input//[[:space:]]/}"

    if [ -z "$input" ]; then
      return 1
    fi

    if [ "$input" = "all" ] || [ "$input" = "ALL" ]; then
      printf '%s\n' "${cleanup_modules[*]}"
      return 0
    fi

    IFS=',' read -r -a picks <<< "$input"

    for token in "${picks[@]}"; do
      [ -z "$token" ] && continue
      case "$token" in
        *[!0-9]*)
          error "Invalid selection token: ${token}"
          return 2
          ;;
      esac

      idx=$((token))
      if [ "$idx" -lt 1 ] || [ "$idx" -gt "${#cleanup_modules[@]}" ]; then
        error "Selection out of range: ${token}"
        return 2
      fi

      selected_module="${cleanup_modules[$((idx - 1))]}"
      case " ${selected} " in
        *" ${selected_module} "*) ;;
        *) selected="${selected}${selected:+ }${selected_module}" ;;
      esac
    done

    if [ -z "$selected" ]; then
      error "No valid modules selected."
      return 2
    fi

    printf '%s\n' "$selected"
  }

  if [ "$interactive" = true ] && [ -n "$module" ]; then
    error "Use either --module or --interactive, not both."
    return 1
  fi

  if [ -n "$module" ]; then
    if ! is_valid_cleanup_module "$module"; then
      error "Unknown cleanup module: ${module}"
      echo "Available modules: trash, caches, logs, downloads, browser, dev,"
      echo "  crash_reports, ios_backups, xcode, dev_caches"
      return 1
    fi
    run_single_cleanup_module "$module" "$force"
    return $?
  fi

  if [ "$interactive" = true ]; then
    local selected_line selection_rc=0 all_rc=0 selected_module
    selected_line="$(select_interactive_modules)" || selection_rc=$?

    if [ "$selection_rc" -eq 1 ]; then
      echo "No modules selected. Cancelled."
      return 0
    fi
    if [ "$selection_rc" -ne 0 ]; then
      return "$selection_rc"
    fi

    for selected_module in $selected_line; do
      echo
      echo "${BOLD}== Running cleanup module: ${selected_module} ==${RESET}"
      run_single_cleanup_module "$selected_module" "$force" || all_rc=$?
    done

    return "$all_rc"
  fi

  # Run full cleanup
  if [ "$force" = true ] && [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" bash "${MDOCTOR_DIR}/cleanup.sh" --force --debug
  elif [ "$force" = true ]; then
    MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" bash "${MDOCTOR_DIR}/cleanup.sh" --force
  elif [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" bash "${MDOCTOR_DIR}/cleanup.sh" --debug
  else
    MDOCTOR_DEBUG="${MDOCTOR_DEBUG}" bash "${MDOCTOR_DIR}/cleanup.sh"
  fi
}

########################################
# COMMAND: fix
########################################

cmd_fix() {
  local target=""
  local debug_flag=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        echo "Usage: mdoctor fix [--debug] <target>"
        echo
        echo "Apply common fixes for system issues."
        echo
        echo "Targets:"
        echo "  dns           [LOW]  Flush DNS cache"
        echo "  disk          [LOW]  Free disk space (cleanup + recommendations)"
        if is_macos; then
          echo "  homebrew      [LOW]  Fix Homebrew issues (update, cleanup, doctor)"
          echo "  permissions   [MED]  Reset disk permissions and rebuild"
          echo "  spotlight     [MED]  Rebuild Spotlight index"
          echo "  bluetooth     [LOW]  Reset Bluetooth module"
          echo "  audio         [LOW]  Restart Core Audio daemon"
          echo "  wifi          [LOW]  Renew DHCP, flush DNS, cycle Wi-Fi"
          echo "  timemachine   [MED]  Verify Time Machine backup integrity"
        fi
        if is_linux; then
          echo "  apt           [LOW]  Fix APT package issues (update, upgrade, autoremove)"
        fi
        echo "  all           Run all applicable fixes"
        echo
        echo "Options:"
        echo "  --debug       Enable structured debug diagnostics"
        echo "  -h, --help    Show this help"
        return 0
        ;;
      --debug)
        debug_flag=true
        shift
        ;;
      *)
        target="$1"
        shift
        ;;
    esac
  done

  if [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG=true
    export MDOCTOR_DEBUG
  fi

  source "${MDOCTOR_DIR}/lib/logging.sh"
  debug_log "cmd_fix target=${target:-<none>} debug=${MDOCTOR_DEBUG}"

  if [ -z "$target" ]; then
    echo "Usage: mdoctor fix [--debug] <target>"
    echo
    echo "Run 'mdoctor fix --help' for available targets."
    return 1
  fi

  # Source fix modules
  local fix_file="${MDOCTOR_DIR}/fixes/${target}.sh"

  case "$target" in
    homebrew|dns|disk|permissions|spotlight|bluetooth|audio|wifi|timemachine|apt)
      if [ -f "$fix_file" ]; then
        # shellcheck source=/dev/null
        source "$fix_file"
        debug_log "fix target start=${target}"
        "fix_${target}"
        local fix_rc=$?
        debug_log "fix target end=${target} rc=${fix_rc}"
        return "$fix_rc"
      else
        error "Fix module not found: ${fix_file}"
        return 1
      fi
      ;;
    all)
      local -a fix_targets=(dns disk)
      if is_macos; then
        fix_targets+=(homebrew permissions spotlight bluetooth audio wifi)
      fi
      if is_linux; then
        fix_targets+=(apt)
      fi

      local t
      local all_rc=0
      for t in "${fix_targets[@]}"; do
        local f="${MDOCTOR_DIR}/fixes/${t}.sh"
        if [ -f "$f" ]; then
          # shellcheck source=/dev/null
          source "$f"
          debug_log "fix target start=${t}"
          local target_rc=0
          "fix_${t}" || target_rc=$?
          if [ "$target_rc" -ne 0 ]; then
            all_rc=$target_rc
          fi
          debug_log "fix target end=${t} rc=${target_rc}"
          echo
        fi
      done
      return "$all_rc"
      ;;
    *)
      error "Unknown fix target: ${target}"
      echo "Run 'mdoctor fix --help' for available targets."
      return 1
      ;;
  esac
}

########################################
# COMMAND: info
########################################

cmd_info() {
  echo "${BOLD}${BLUE}== System Information ==${RESET}"
  echo

  local arch uptime_str
  arch=$(uname -m 2>/dev/null || echo "Unknown")
  uptime_str=$(uptime | sed 's/.*up *//; s/, *[0-9]* user.*//')

  printf "  %-20s %s\n" "OS:" "$(platform_name)"
  printf "  %-20s %s\n" "Architecture:" "${arch}"
  printf "  %-20s %s\n" "Hostname:" "$(hostname)"
  printf "  %-20s %s\n" "Uptime:" "${uptime_str}"
  printf "  %-20s %s\n" "User:" "$(whoami)"
  printf "  %-20s %s\n" "Shell:" "${SHELL}"

  # Disk
  local disk_root="/"
  if is_macos; then
    [ -d /System/Volumes/Data ] && disk_root="/System/Volumes/Data"
  fi
  local disk_info
  disk_info=$(df -h "$disk_root" | awk 'NR==2 {print $3" used / "$2" total ("$5" used)"}')
  printf "  %-20s %s\n" "Disk:" "${disk_info}"

  # Memory
  if is_macos && command -v vm_stat >/dev/null 2>&1; then
    local page_size active_pages wired_pages
    page_size=$(sysctl -n hw.pagesize 2>/dev/null || echo 4096)
    active_pages=$(vm_stat | awk '/Pages active/ {gsub("\\.","",$3); print $3}')
    wired_pages=$(vm_stat | awk '/Pages wired down/ {gsub("\\.","",$4); print $4}')

    local total_mem
    total_mem=$(sysctl -n hw.memsize 2>/dev/null || echo 0)
    local total_gb
    total_gb=$(awk -v m="$total_mem" 'BEGIN {printf "%.0f", m/1073741824}')
    local used_kb
    used_kb=$(( (active_pages + wired_pages) * page_size / 1024 ))
    local used_gb
    used_gb=$(awk -v kb="$used_kb" 'BEGIN {printf "%.1f", kb/1048576}')

    printf "  %-20s %s\n" "Memory:" "${used_gb} GB used / ${total_gb} GB total"
  elif is_linux && [ -r /proc/meminfo ]; then
    local mem_total mem_avail mem_used_kb total_gb used_gb
    mem_total=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
    mem_avail=$(awk '/MemAvailable/ {print $2}' /proc/meminfo)
    mem_used_kb=$((mem_total - mem_avail))
    total_gb=$(awk -v m="$mem_total" 'BEGIN {printf "%.0f", m/1048576}')
    used_gb=$(awk -v kb="$mem_used_kb" 'BEGIN {printf "%.1f", kb/1048576}')

    printf "  %-20s %s\n" "Memory:" "${used_gb} GB used / ${total_gb} GB total"
  fi

  # CPU
  local cpu_brand
  if is_macos; then
    cpu_brand=$(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "Unknown")
  elif [ -r /proc/cpuinfo ]; then
    cpu_brand=$(grep -m1 'model name' /proc/cpuinfo 2>/dev/null | cut -d: -f2 | sed 's/^ *//')
    [ -z "$cpu_brand" ] && cpu_brand="Unknown"
  else
    cpu_brand="Unknown"
  fi
  printf "  %-20s %s\n" "CPU:" "${cpu_brand}"

  # Load
  local load
  if is_macos; then
    load=$(sysctl -n vm.loadavg 2>/dev/null | awk '{print $2", "$3", "$4}')
  else
    load=$(awk '{print $1", "$2", "$3}' /proc/loadavg 2>/dev/null || echo "Unknown")
  fi
  printf "  %-20s %s\n" "Load (1/5/15m):" "${load}"

  # Key tools
  echo
  echo "${BOLD}  Installed Tools:${RESET}"
  local -a tools=("git" "node" "npm" "python3" "pip3" "docker" "code" "java")
  if is_macos; then
    tools=("brew" "${tools[@]}")
  fi
  for tool in "${tools[@]}"; do
    if command -v "$tool" >/dev/null 2>&1; then
      local ver
      case "$tool" in
        brew)    ver=$(brew --version 2>/dev/null | head -n1) ;;
        git)     ver=$(git --version 2>/dev/null) ;;
        node)    ver=$(node -v 2>/dev/null) ;;
        npm)     ver=$(npm -v 2>/dev/null) ;;
        python3) ver=$(python3 --version 2>/dev/null) ;;
        pip3)    ver=$(pip3 --version 2>/dev/null | awk '{print $2}') ;;
        docker)  ver=$(docker --version 2>/dev/null) ;;
        code)    ver=$(code --version 2>/dev/null | head -n1) ;;
        java)    ver=$(java -version 2>&1 | head -n1) ;;
        *)       ver="installed" ;;
      esac
      printf "    ${GREEN}%-12s${RESET} %s\n" "${tool}" "${ver}"
    fi
  done
  echo
}

########################################
# COMMAND: list
########################################

cmd_list() {
  source "${MDOCTOR_DIR}/lib/metadata.sh"

  # Register all modules for listing (platform-filtered)
  # Check modules — Hardware
  if is_macos; then
    register_module check battery    Hardware SAFE check_battery     "Battery health, cycle count, capacity"
  fi
  register_module check hardware   Hardware SAFE check_hardware    "CPU, RAM, model, thermals"
  if is_macos; then
    register_module check bluetooth  Hardware SAFE check_bluetooth   "Bluetooth power state & devices"
    register_module check usb        Hardware SAFE check_usb         "Connected USB devices"
  fi
  # Check modules — System
  register_module check system      System SAFE check_system        "OS version, memory, load average"
  register_module check disk        System SAFE check_disk          "Disk usage & health"
  register_module check updates     System SAFE check_updates_basic "System updates"
  register_module check security    System SAFE check_security      "Firewall, encryption, security settings"
  register_module check startup     System SAFE check_startup       "Startup services & agents"
  register_module check network     System SAFE check_network       "Connectivity, DNS, Wi-Fi signal"
  register_module check performance System SAFE check_performance   "Memory pressure, CPU, processes"
  register_module check storage     System SAFE check_storage       "Large files & app storage analysis"
  # Check modules — Software
  if is_macos; then
    register_module check homebrew   Software SAFE check_homebrew    "Homebrew installation & packages"
  fi
  register_module check node       Software SAFE check_node_npm    "Node.js & npm"
  register_module check python     Software SAFE check_python      "Python & pip"
  register_module check devtools   Software SAFE check_dev_tools   "Developer tools, Git, Docker"
  register_module check shell      Software SAFE check_shell_configs "Shell config syntax"
  register_module check apps       Software SAFE check_apps        "Crash reports, application health"
  register_module check git_config Software SAFE check_git_config  "Git & SSH configuration"
  register_module check containers Software SAFE check_containers  "Docker & container health"
  if is_linux; then
    register_module check apt      Software SAFE check_apt         "APT package manager health"
  fi

  # Cleanup modules
  register_module cleanup trash         System   LOW clean_trash               "Empty Trash"
  register_module cleanup caches        System   LOW clean_user_caches         "User cache directories"
  register_module cleanup logs          System   LOW clean_logs                "Old log files"
  register_module cleanup downloads     System   LOW clean_downloads_large_files "Large files in Downloads"
  register_module cleanup crash_reports System   LOW clean_crash_reports       "Old crash/diagnostic reports"
  if is_macos; then
    register_module cleanup ios_backups   System   LOW clean_ios_backups         "Old iOS device backups"
  fi
  register_module cleanup browser       Software LOW clean_browser_caches      "Browser cache cleanup"
  register_module cleanup dev           Software LOW clean_dev_stuff           "Developer tool caches"
  if is_macos; then
    register_module cleanup xcode         Software LOW clean_xcode              "Xcode DerivedData, archives, simulators"
  fi
  register_module cleanup dev_caches    Software LOW clean_dev_caches         "Developer dependency & package caches"
  if is_linux; then
    register_module cleanup apt          System   LOW clean_apt_cache          "APT package cache cleanup"
  fi

  # Fix modules
  register_module fix dns         System   LOW  fix_dns         "Flush DNS cache"
  register_module fix disk        System   LOW  fix_disk        "Free disk space"
  if is_macos; then
    register_module fix homebrew    Software LOW  fix_homebrew    "Update, upgrade, cleanup Homebrew"
    register_module fix permissions System   MED  fix_permissions "Reset file permissions"
    register_module fix spotlight   System   MED  fix_spotlight   "Rebuild Spotlight index"
    register_module fix bluetooth   Hardware LOW  fix_bluetooth   "Reset Bluetooth module"
    register_module fix audio       System   LOW  fix_audio       "Restart Core Audio daemon"
    register_module fix wifi        System   LOW  fix_wifi        "Renew DHCP, flush DNS, cycle Wi-Fi"
    register_module fix timemachine System   MED  fix_timemachine "Verify Time Machine backups"
  fi
  if is_linux; then
    register_module fix apt        System   LOW  fix_apt         "Fix APT packages (update, upgrade, autoremove)"
  fi

  echo "${BOLD}${BLUE}== All Modules ($(platform_name)) ==${RESET}"
  echo

  echo "${BOLD}Check Modules (${_MOD_COUNT:-0} — all read-only):${RESET}"
  list_modules_by_category check
  echo

  echo "${BOLD}Cleanup Modules:${RESET}"
  list_modules_by_category cleanup
  echo

  echo "${BOLD}Fix Targets:${RESET}"
  list_modules_by_category fix
  echo
}

########################################
# COMMAND: history
########################################

cmd_history() {
  source "${MDOCTOR_DIR}/lib/history.sh"

  echo "${BOLD}${BLUE}== Health Score History ==${RESET}"
  echo
  history_show "${1:-10}"
}

########################################
# COMMAND: benchmark
########################################

cmd_benchmark() {
  source "${MDOCTOR_DIR}/lib/benchmark.sh"
  run_benchmark
}

########################################
# COMMAND: version
########################################

cmd_version() {
  echo "mdoctor ${MDOCTOR_VERSION_FULL}"
}

########################################
# COMMAND: update
########################################

cmd_update() {
  local check_only=false
  local channel="stable"
  local debug_flag=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --check)
        check_only=true
        shift
        ;;
      --channel)
        if [[ $# -lt 2 || -z "${2:-}" ]]; then
          error "Missing value for --channel"
          return 1
        fi
        channel="$2"
        shift 2
        ;;
      --debug)
        debug_flag=true
        shift
        ;;
      --help|-h)
        echo "Usage: mdoctor update [options]"
        echo
        echo "Update mdoctor to the latest stable release."
        echo
        echo "Options:"
        echo "  --check              Check for updates without applying"
        echo "  --channel <name>     Update channel (supported: stable)"
        echo "  --debug              Enable structured debug diagnostics"
        echo "  -h, --help           Show this help"
        echo
        echo "Environment Variables:"
        echo "  MDOCTOR_UPDATE_REMOTE   Override git remote (default: origin)"
        echo "  MDOCTOR_UPDATE_BRANCH   Override git branch (default: main)"
        return 0
        ;;
      *)
        error "Unknown option: $1"
        echo "Run 'mdoctor update --help' for usage."
        return 1
        ;;
    esac
  done

  if [ "$debug_flag" = true ]; then
    MDOCTOR_DEBUG=true
    export MDOCTOR_DEBUG
  fi

  if [ "$channel" != "stable" ]; then
    error "Unsupported update channel: ${channel}"
    echo "Supported channels: stable"
    return 1
  fi

  if ! command -v git >/dev/null 2>&1; then
    error "git is required for updates but not found."
    return 1
  fi

  if [ ! -d "${MDOCTOR_DIR}/.git" ]; then
    error "Update requires a git checkout at ${MDOCTOR_DIR}."
    echo "Reinstall with: curl -fsSL https://raw.githubusercontent.com/luongnv89/mdoctor/main/install.sh | bash"
    return 1
  fi

  local remote="${MDOCTOR_UPDATE_REMOTE:-origin}"
  local branch="${MDOCTOR_UPDATE_BRANCH:-main}"
  local remote_ref="${remote}/${branch}"

  if [ "${MDOCTOR_DEBUG}" = "true" ]; then
    echo "${DIM}[debug]${RESET} update remote=${remote} branch=${branch} check_only=${check_only}"
  fi

  echo "${DIM}mdoctor v${MDOCTOR_VERSION_FULL}${RESET}"
  echo "Checking updates from ${remote_ref}..."

  if ! git -C "$MDOCTOR_DIR" fetch --quiet "$remote" "$branch"; then
    error "Failed to fetch updates from ${remote_ref}."
    return 1
  fi

  local local_sha remote_sha local_short remote_short
  local_sha="$(git -C "$MDOCTOR_DIR" rev-parse HEAD 2>/dev/null || true)"
  remote_sha="$(git -C "$MDOCTOR_DIR" rev-parse "$remote_ref" 2>/dev/null || true)"

  if [ -z "$local_sha" ] || [ -z "$remote_sha" ]; then
    error "Unable to resolve local/remote git refs for update check."
    return 1
  fi

  local_short="$(git -C "$MDOCTOR_DIR" rev-parse --short "$local_sha")"
  remote_short="$(git -C "$MDOCTOR_DIR" rev-parse --short "$remote_sha")"

  if [ "$local_sha" = "$remote_sha" ]; then
    echo "Already up to date (${local_short})."
    return 0
  fi

  echo "Update available: ${local_short} -> ${remote_short}"

  if [ "$check_only" = true ]; then
    return 0
  fi

  if ! git -C "$MDOCTOR_DIR" pull --ff-only "$remote" "$branch"; then
    error "Update failed. Repository may have local changes or diverged history."
    echo "Try resolving git state manually in: ${MDOCTOR_DIR}"
    return 1
  fi

  chmod +x "${MDOCTOR_DIR}/mdoctor" "${MDOCTOR_DIR}/doctor.sh" "${MDOCTOR_DIR}/cleanup.sh" 2>/dev/null || true
  if [ -d "${MDOCTOR_DIR}/fixes" ]; then
    chmod +x "${MDOCTOR_DIR}"/fixes/*.sh 2>/dev/null || true
  fi

  local new_short
  new_short="$(git -C "$MDOCTOR_DIR" rev-parse --short HEAD 2>/dev/null || echo "$remote_short")"

  echo "Update complete: ${local_short} -> ${new_short}"
  echo "Current version: $(${MDOCTOR_DIR}/mdoctor version 2>/dev/null || echo "mdoctor ${MDOCTOR_VERSION_FULL}")"
}

########################################
# COMMAND: help
########################################

cmd_help() {
  banner
  echo "Usage: ${BOLD}mdoctor${RESET} <command> [options]"
  echo
  echo "${BOLD}Commands:${RESET}"
  printf "  ${GREEN}%-12s${RESET} %s\n" "check"     "Run system health audit (read-only, 21 checks)"
  printf "  ${GREEN}%-12s${RESET} %s\n" "clean"     "Run system cleanup (dry-run by default, 10 modules)"
  printf "  ${GREEN}%-12s${RESET} %s\n" "fix"       "Apply common fixes (9 targets)"
  printf "  ${GREEN}%-12s${RESET} %s\n" "info"      "Show system information summary"
  printf "  ${GREEN}%-12s${RESET} %s\n" "list"      "List all modules with category & risk level"
  printf "  ${GREEN}%-12s${RESET} %s\n" "history"   "View health score trends over time"
  printf "  ${GREEN}%-12s${RESET} %s\n" "benchmark" "Run disk, network, CPU benchmarks"
  printf "  ${GREEN}%-12s${RESET} %s\n" "update"    "Update mdoctor to latest stable release"
  printf "  ${GREEN}%-12s${RESET} %s\n" "version"   "Show mdoctor version"
  printf "  ${GREEN}%-12s${RESET} %s\n" "help"      "Show this help message"
  echo
  echo "${BOLD}Check Modules${RESET} (all [SAFE] read-only):"
  if is_macos; then
    echo "  Hardware:  battery, hardware, bluetooth, usb"
    echo "  System:    system, disk, updates, security, startup, network, performance, storage"
    echo "  Software:  homebrew, node, python, devtools, shell, apps, git_config, containers"
  else
    echo "  Hardware:  hardware"
    echo "  System:    system, disk, updates, security, startup, network, performance, storage"
    echo "  Software:  node, python, devtools, shell, apps, git_config, containers, apt"
  fi
  echo
  echo "${BOLD}Cleanup Modules${RESET} (all [LOW] risk):"
  if is_macos; then
    echo "  System:    trash, caches, logs, downloads, crash_reports, ios_backups"
    echo "  Software:  browser, dev, xcode, dev_caches"
  else
    echo "  System:    trash, caches, logs, downloads, crash_reports, apt"
    echo "  Software:  browser, dev, dev_caches"
  fi
  echo
  echo "${BOLD}Fix Targets${RESET}:"
  if is_macos; then
    echo "  [LOW]  homebrew, dns, disk, bluetooth, audio, wifi"
    echo "  [MED]  permissions, spotlight, timemachine"
  else
    echo "  [LOW]  dns, disk, apt"
  fi
  echo
  echo "${BOLD}Examples:${RESET}"
  echo "  mdoctor check                    # Full health audit (21 checks)"
  echo "  mdoctor check -m battery         # Check only battery health"
  echo "  mdoctor check --json             # JSON output for automation"
  echo "  mdoctor check --debug            # Check with structured debug diagnostics"
  echo "  mdoctor clean                    # Dry-run cleanup"
  echo "  mdoctor clean --force            # Actually clean up"
  echo "  mdoctor clean --debug            # Cleanup with structured debug diagnostics"
  echo "  mdoctor clean -m crash_reports   # Clean only crash reports"
  echo "  mdoctor fix homebrew             # Fix Homebrew issues"
  echo "  mdoctor fix wifi                 # Fix Wi-Fi connection"
  echo "  mdoctor fix --debug wifi         # Fix with structured debug diagnostics"
  echo "  mdoctor fix all                  # Run all fixes"
  echo "  mdoctor list                     # Show all modules"
  echo "  mdoctor history                  # View score trends"
  echo "  mdoctor benchmark                # Run speed tests"
  echo "  mdoctor update --check           # Check if stable updates are available"
  echo "  mdoctor update                   # Update to latest stable release"
  echo "  mdoctor info                     # Quick system overview"
  echo
  echo "${BOLD}Environment Variables:${RESET}"
  echo "  DAYS_OLD_OVERRIDE=N              Override cleanup age threshold (default: 7)"
  echo "  MDOCTOR_CLEANUP_WHITELIST_FILE   Override cleanup whitelist file path"
  echo "  MDOCTOR_CLEANUP_SCOPE_FILE       Override cleanup scope config file path"
  echo "  MDOCTOR_UPDATE_REMOTE            Override update git remote (default: origin)"
  echo "  MDOCTOR_UPDATE_BRANCH            Override update git branch (default: main)"
  echo
  echo "${DIM}Documentation: https://github.com/luongnv89/mdoctor${RESET}"
}

########################################
# MAIN DISPATCH
########################################

main() {
  local command="${1:-}"
  shift 2>/dev/null || true

  case "$command" in
    check)     cmd_check "$@" ;;
    clean)     cmd_clean "$@" ;;
    fix)       cmd_fix "$@" ;;
    info)      cmd_info ;;
    list)      cmd_list ;;
    history)   cmd_history "$@" ;;
    benchmark) cmd_benchmark ;;
    update)    cmd_update "$@" ;;
    version)   cmd_version ;;
    -v|--version) cmd_version ;;
    help|-h|--help) cmd_help ;;
    "")        cmd_help ;;
    *)
      error "Unknown command: ${command}"
      echo "Run 'mdoctor help' for usage."
      return 1
      ;;
  esac
}

main "$@"
